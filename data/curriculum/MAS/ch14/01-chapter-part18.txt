willfocus valueiteration onanolder,dynamic-programming-stylemethodcalledvalueiteration. Wedoso for two reasons. First, in typical real-world cases of interest, the LP-formulation of the MDP is too large to solve. Value iteration providesthe basis for a number ofmorepracticalsolutions,suchasthoseprovidingapproximatesolutionstovery large MDPs. Second, value iteration is relevant to the discussion of learning in MDPs,discussedinChapter7. ValueiterationdefinesavaluefunctionVπ : S R,whichspecifiesthevalue 7→ of following policy π starting in state s. Similarly, we can define a state-action valuefunctionQπ : S A Rasa functionthatcapturesthevalueofstarting × 7→ in state s, taking action a, andthen continuingaccordingto policy π. These two functionsarerelatedtoeachotherbythefollowingpairofequations. Qπ(s,a) = r(s,a)+β p(s,a,sˆ)Vπ(sˆ) sˆ X Vπ(s) = Qπ(s,π(s)) Fortheoptimalpolicyπ∗,thesecondequationbecomesVπ∗(s) = max Qπ∗(s,a) a Bellman andthesetofequationsisreferredtoastheBellmanequations. Notethattheoptiequations malpolicyis easilyrecoveredfromthesolutiontotheBellmanequations,specificallyfromtheQfunction;theoptimalactioninstatesisargmax Qπ∗(s,a). a TheBellmanequationsareinterestingnotonlybecausetheycharacterizetheoptimalpolicy,butalso—indeed,primarily—becausetheygiverisetoaprocedurefor calculatingtheQandV valuesoftheoptimalpolicy,andhencetheoptimalpolicy itself. ConsiderthefollowingtwoassignmentversionsoftheBellmanequations. Q (s,a) r(s,a)+β p(s,a,sˆ)V (sˆ) t+1 t ← sˆ X V (s) maxQ (s,a) t t ← a Given an MDP, and starting with arbitrary initial Q values, we can repeatedly iterate thesetwo sets ofassignmentoperators(“sets,” sinceeachchoiceof s anda produces a different instance). It is well known that any “fair" order of iteration (bywhichwemeanthateachinstanceoftherulesisupdatedafterafiniteamount oftime)convergesontheQandV valuesofanoptimalpolicy. UncorrectedmanuscriptofMultiagentSystems,publishedbyCambridgeUniversityPress Revision1.1©Shoham&Leyton-Brown,2009,2010. D Classical Logic The following is not intended as an introduction to classical logic, but rather as a review of the concepts and a setting of notation. We start with propositional calculusandthenmovetofirst-orderlogic. (Wedothelatterforcompleteness,but infactfirst-orderlogicplaysalmostnoroleinthisbook.) D.1 Propositionalcalculus Syntax Given a set P of propositionalsymbols, the set of sentences in the propositional calculusisthesmallestset containingP suchthatifϕ,ψ thenalso ϕ L ∈ L ¬ ∈ L andϕ ψ . Otherconnectivessuchas , ,and canbedefinedinterms ∧ ∈ L ∨ → ≡ of and . ∧ ¬ Semantics interpretation A propositional interpretation (or a model) is a set M P, the subset of true ⊂ primitivepropositions. Thesatisfactionrelation =betweenmodelsandsentences model | isdefinedrecursivelyasfollows. • Foranyp P,M = piffp M. ∈ | ∈ • M = ϕ ψiffM = ϕandM = ψ. | ∧ | | • M = ϕiffitisnotthecasethatM = ϕ. | ¬ | validity Weoverloadthe =symbol. First,itisusedtodenotevalidity; = ϕmeansthatϕ | | istrueinallpropositionalmodels. Second,itisusedtodenoteentailment;ϕ = ψ entailment | meansthatanymodelthatsatisfiesϕalsosatisfiesψ. Axiomatics Thefollowingaxiomsystemissoundandcompletefortheclassofallpropositional models: 478 D ClassicalLogic A1. A (B A) → → A2. (A (B C)) ((A B) (A C)) → → → → → → A3. ( A B) (B A) ¬ → ¬ → → R1(ModusPonens). A,A B B. → ⊢ D.2 First-orderlogic This bookmakes verylittle referenceto first-order constructs, butwe includethe basicmaterialonthefirst-orderlogicforcompleteness. Syntax GivenasetC ofconstantsymbols,V ofvariables,F offunctionsymbolseachof a givenarity, and R of relation (or predicate)symbols each of a given arity. The setoftermsisthesmallestsetT suchthatC V T,andiff F isann-ary ∪ ⊂ ∈ functions symbol and t ,...,t T then also f(t ,...,t ) T. The set of 1 n 1 n ∈ ∈ sentencesisthesmallestset satisfyingthefollowingconditions. L If r is an n-ary relation symbol and t ,...,t T then r(t ,...,t ) . 1 n 1 n ∈ ∈ L Thesearetheatomicsentences. Ifϕ,ψ thenalso ϕ andϕ ψ . ∈ L ¬ ∈L ∧ ∈ L Ifϕ andv V then vϕ L. ∈ L ∈ ∀ ∈ Semantics interpretation A first-order interpretation (or a model) is a tuple M = (D,G,S,µ). D is the domain of M, a set. G is a set of functions