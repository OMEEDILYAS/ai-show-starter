2 Distributed Optimization Inthepreviouschapterwelookedatdistributedwaysofmeetingglobalconstraints. Here we up the ante; we ask how agents can, in a distributed fashion, optimize a globalobjectivefunction.Specifically,weconsiderfourfamiliesoftechniquesand associatedsampleproblems. Theyare,inorder: • Distributeddynamicprogramming(asappliedtopath-planningproblems). • DistributedsolutionstoMarkovDecisionProblems(MDPs). • Optimization algorithms with an economic flavor (as applied to matching and schedulingproblems). • Coordinationviasociallawsandconventions,andtheexampleoftrafficrules. 2.1 Distributed dynamicprogramming forpath planning Likegraphcoloring,pathplanningconstitutesanothercommonabstractproblemsolvingframework.Apath-planningproblemconsistsofaweighteddirectedgraph withasetofnnodesN,directedlinksL,aweightfunctionw : L R+,andtwo 7→ nodess,t N. Thegoalistofindadirectedpathfromstothavingminimaltotal ∈ weight. Moregenerally,weconsiderasetofgoalnodesT N,andareinterested ⊂ intheshortestpathfromstoanyofthegoalnodest T. ∈ This abstract framework applies in many domains. Certainly it applies when thereissomeconcretenetworkathand(e.g.,atransportationortelecommunication network). Butitalsoappliesinmoreroundaboutways. Forexample,inaplanning problemthenodescanbestatesoftheworld,thearcsactionsavailabletotheagent, andtheweightsthecost(or,alternatively,time)ofeachaction. 2.1.1 Asynchronousdynamicprogramming Path planning is a well-studied problem in computer science and operations research. We are interested in distributed solutions, in which eachnodeperformsa local computation, with access only to the state of its neighbors. Underlying our 20 2 DistributedOptimization principleof solutionswillbetheprincipleofoptimality: ifnodexliesonashortestpathfroms optimality tot,thentheportionofthepathfromstox(or,respectively,fromxtot)mustalso betheshortestpathsbetweensandx(resp.,xandt). Thisallowsanincremental dynamic divide-and-conquerprocedure,alsoknownasdynamicprogramming. programming Let us represent the shortest distance from any node i to the goal t as h∗(i). Thus the shortest distance from i to t via a node j neighboring i is given by f∗(i,j) = w(i,j) + h∗(j), and h∗(i) = min f∗(i,j). Based on these facts, j asynchronous the ASYNCHDP algorithmhaseachnoderepeatedlyperformthefollowingprocedynamic dure. Inthisprocedure,giveninFigure2.1,eachnodeimaintainsavariableh(i), programming whichisanestimateofh∗(i). procedureASYNCHDP (nodei) ifiisagoalnodethen h(i) 0 ← else initializeh(i)arbitrarily(e.g.,to or0) ∞ repeat forallneighborsj do f(j) w(i,j)+h(j) ← h(i) min f(j) j ← Figure2.1: Theasynchronousdynamicprogrammingalgorithm. Figure2.2showsthisalgorithminaction. Thehvaluesareinitializedto ,and ∞ incrementally decrease to their correct values. The figure shows three iterations; notethatafterthefirstiteration,notallfinitehvaluesarecorrect;inparticular,the value 3 in node d still overestimates the true distance, which is corrected in the nextiteration. Onecanprovethatthe ASYNCHDP procedureis guaranteedtoconvergetothe true values, that is, h will convergeto h∗. Specifically, convergencewill require one step for each node in the shortest path, meaning that in the worst case convergencewill require n iterations. However,forrealistic problemsthis is oflittle comfort. Notonlycanconvergencebeslow,butthisprocedureassumesaprocess (or agent) for each node. In typical search spaces one cannoteffectively enumerate all nodes, let alone allocate them each a process. (For example, chess has approximately10120 boardpositions, whereasthereare fewerthan 1081 atoms in theuniverseandtherehaveonlybeen1026nanosecondssincetheBigBang.)Soto bepracticalweturntoheuristicversionsoftheprocedure,whichrequireasmaller number of agents. Let us start by considering the opposite extreme in which we haveonlyoneagent. ∗ 2.1.2 Learningreal-timeA learning Inthelearningreal-timeA∗,orLRTA∗,algorithm,theagentstartsatagivennode, real-timeA∗ (LRTA∗) UncorrectedmanuscriptofMultiagentSystems,publishedbyCambridgeUniversityPress Revision1.1©Shoham&Leyton-Brown,2009,2010. 2.1 Distributeddynamicprogrammingforpathplanning 21 ∞ ∞ ∞ 1 2 - 2 - a c a c 1(cid:0) (cid:0)(cid:18) i (cid:0)(cid:0)(cid:18) 6i @ 1 1(cid:0) (cid:0)(cid:18) i (cid:0)(cid:0)(cid:18) 6i @ 1 ∞ (cid:0) (cid:0) @ @R0 ∞ (cid:0) (cid:0) @ @R0 s 1 2 (cid:0) 1 t s 1 2 (cid:0) 1 t (cid:0) (cid:0) @ (cid:0)(cid:18) @ (cid:0)(cid:18) i (cid:0) (cid:0) i i (cid:0) (cid:0) i 3@ @R ?(cid:0) (cid:0) 3 3@ @R ?(cid:0) (cid:0) 3 - - b d b d ∞ 2 ∞ ∞ 2 3 i (i) i i (ii) i 3 1 2 - a c 1(cid:0) (cid:0)(cid:18) i (cid:0)(cid:0)(cid:18) 6i @ 1 ∞ (cid:0) (cid:0) @ @R0 s 1 2 (cid:0) 1 t (cid:0) @ (cid:0)(cid:18) i (cid:0) (cid:0) i 3@ @R ?(cid:0) (cid:0) 3 - b d 2 3 2 i (iii) i Figure2.2: Asynchronousdynamicprogramminginaction performsanoperationsimilartothatofasynchronousdynamicprogramming,and thenmovestotheneighboringnodewiththeshortestestimateddistancetothegoal, andrepeats. TheprocedureisgiveninFigure2.3. procedureLRTA∗ i s //thestartnode ← whileiisnotagoalnodedo foreachneighborj do f(j) w(i,j)+h(j) ← i′ argmin f(j) //breakingtiesatrandom j ←