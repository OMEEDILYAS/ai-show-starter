{ } he can also construct the Nogood x = blue,x = red . x then sends both 2 3 1 { } Nogoodsto his neighborsx and x . Using his domain, an existing Nogoodand 2 3 oneofthesenewNogoods,x canreason: 2 x = red x = blue 2 2 ∨ (x = red x = blue) 2 3 ¬ ∧ (x = blue x = blue) 2 3 ¬ ∧ (x = blue) 3 ¬ UsingtheothernewNogoodfromx ,x canalsoconstructtheNogood x = 1 2 3 { red . These two singleton Nogoods are communicated to x and allow him to 3 } generatetheemptyNogood. Thisprovesthattheproblemdoesnothaveasolution. This example, while demonstrating the greater power of the hyper-resolutionbased algorithm relative to the filtering algorithm, also exposesits weakness; the number of Nogoods generated can grow to be unmanageablylarge. (Indeed, we only described the minimal number of Nogoods needed to derive the empty Nogood;manyotherswouldbecreatedas alltheagentsprocessedeachother’smessagesinparallel. Canyoufindanexample?) Thus,thesituationinwhichwefind ourselves is that we have one algorithm that is too weak and another that is impractical. The problem lies in the least-commitment nature of these algorithms; theyarerestrictedtoremovingonlyprovablyimpossiblevaluecombinations. The alternative to such “safe” procedures is to explore a subset of the space, making tentativevalueselectionsforvariables, andbacktrackingwhennecessary. This is the topic ofthe nextsection. However,the algorithmswe havejust describedare not irrelevant; the filtering algorithm is an effective preprocessing step, and the algorithmwediscussnextisbasedonthehyper-resolution-basedalgorithm. 1.3 Heuristicsearchalgorithms Astraightforwardcentralizedtrial-and-errorsolutiontoaCSPistofirstorderthe variables (e.g., alphabetically). Then, given the ordering x ,x ,...,x , invoke 1 2 n theprocedureChooseValue(x , ). TheprocedureChooseValueisdefinedrecur1 {} sivelyasfollows,where v ,v ,...,v isthesetofvaluesassignedtovariables 1 2 i−1 { } x ,...,x . 1 i−1 UncorrectedmanuscriptofMultiagentSystems,publishedbyCambridgeUniversityPress Revision1.1©Shoham&Leyton-Brown,2009,2010. 1.3 Heuristicsearchalgorithms 9 procedureChooseValue(x , v ,v ,...,v ) i 1 2 i−1 { } v valuefromthedomainofx thatisconsistentwith v ,v ,...,v i i 1 2 i−1 ← { } if nosuchvalueexiststhen backtrack1 elseif i =nthen stop else ChooseValue(x , v ,v ,...,v ) i+1 1 2 i { } chronological This exhaustivesearch of the space of assignments has the advantage of combacktracking pleteness. But it is “distributed” only in the uninterestingsense that the different agentsexecutesequentially,mimickingtheexecutionofacentralizedalgorithm. The following attempt at a distributed algorithm has the opposite properties; it allows the agents to execute in parallel and asynchronously, is sound, but is not complete. Considerthefollowingnaiveprocedure,executedbyallagentsinparallelandasynchronously. selectavaluefromyourdomain repeat if yourcurrentvalueisconsistentwiththecurrentvaluesofyour neighbors,orifnoneofthevaluesinyourdomainareconsistentwiththem then donothing else selectavalueinyourdomainthatisconsistentwiththoseofyour neighborsandnotifyyourneighborsofyournewvalue untilthereisnochangeinyourvalue Clearly, when the algorithm terminates because no constraint violations have occurred,a solutionhasbeenfound. Butin allothercases, allbets areoff. Ifthe algorithmterminatesbecausenoagentcanfindavalueconsistentwiththoseofhis neighbors,theremightstill be a consistentglobalassignment. Andthe algorithm mayneverterminateevenifthereisasolution. Forexample,considerexample(d) ofFigure1.4: ifeveryagentcyclessequentiallybetweenred,green,andblue,the algorithmwillneverterminate. We have given these two straw-man algorithms for two reasons. Our first reason is to show that reconciling true parallelism and asynchrony with soundness andcompletenessis likelytorequiresomewhatcomplexalgorithms. Andsecond, 1. Therearevariouswaystoimplementthebacktrackinginthisprocedure. Themoststraightforwardway istoundothechoices madethusfarinreversechronological order, aprocedureknownaschronological backtracking. Itiswellknownthatmoresophisticatedbacktrackingprocedurescanbemoreefficient,but thatdoesnotconcernushere. Freeforon-screenuse;pleasedonotdistribute.Youcangetanotherfreecopy ofthisPDFororderthebookathttp://www.masfoundations.org. 10 1 DistributedConstraintSatisfaction thefundamentalheuristicalgorithmfordistributedCSPs—theasynchronousbackABTalgorithm tracking(orABT)algorithm—sharesmuchwiththetwoalgorithms.Fromthefirst algorithmitborrowsthenotionofaglobaltotalorderingontheagents. Fromthe secondit borrowsa message-passingprotocol,albeit a morecomplexone, which reliesontheglobalordering. WewilldescribetheABTinitssimplestform. After demonstratingitonanextendedexample,wewillpointtowaysinwhichitcanbe improvedupon. 1.3.1 Theasynchronousbacktrackingalgorithm Aswesaid,theasynchronousbacktracking(ABT)algorithmassumesatotalordering (the “priority order") on the agents. Each binary constraint is known to both theconstrainedagentsandischeckedinthealgorithmbytheagentwiththelower prioritybetweenthetwo. Alinkintheconstraintnetworkisalwaysdirectedfrom anagentwithhigherprioritytoanagentwithlowerpriority. Agentsinstantiatetheirvariablesconcurrentlyandsendtheirassignedvaluesto the agents that are connected to them by outgoing links. All agents wait for and respondtomessages. Aftereachupdateofhisassignment,anagentsendshisnew assignmentalongalloutgoinglinks. An agentwhoreceivesanassignment(from the higher-priority agent of