# .github/workflows/daily.yml
name: Daily Reel

on:
  workflow_dispatch:
    inputs:
      series:
        description: "Choose one series (math_of_ML | MAS | mixed). Leave empty to run all."
        required: false
        default: ""
  schedule:
    # 10:05a Chicago (15:05 UTC)
    - cron: "5 15 * * *"

concurrency:
  group: daily-reel-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  actions: read

env:
  PYTHONUNBUFFERED: 1
  PYTHONPATH: ${{ github.workspace }}
  BG_COLOR: 0x101426
  VIS_GEN_MODEL: gpt-4o-mini

jobs:
  build:
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        series: ${{ fromJSON( (github.event.inputs.series != '' && format('["{0}"]', github.event.inputs.series)) || '["math_of_ML","MAS","mixed"]' ) }}

    steps:
      # --------- CHECKOUT & PYTHON ---------
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install system deps (ffmpeg, fonts, jq, curl)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y ffmpeg fonts-dejavu-core jq curl

      - name: Install Python deps (prefer vendor wheels)
        run: |
          set -e
          python -m pip install --upgrade pip wheel
          if [ -d vendor/wheels ]; then
            echo "Installing from vendor/wheels…"
            python -m pip install --no-index --find-links vendor/wheels \
              numpy pillow matplotlib networkx graphviz \
              plotly kaleido vpython moderngl moderngl-window \
              pyyaml requests orjson pandas openai
          else
            echo "vendor/wheels not found; installing from PyPI…"
            python -m pip install \
              numpy pillow matplotlib networkx graphviz \
              plotly kaleido vpython moderngl moderngl-window \
              pyyaml requests orjson pandas openai
          fi

      - name: Prepare folders
        run: |
          set -e
          mkdir -p "out/${{ matrix.series }}"

      # --------- PLAN & NARRATION ----------
      - name: Plan next episode
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python planner/plan_next.py --series "${SERIES}"
      
      - name: Sync latest → newest episode (plan.json)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          series="${SERIES:?SERIES env missing}"
          root="out/${series}"

          # Ensure at least one episode exists; if not, create one now
          if ! ls -d "${root}"/ep_* >/dev/null 2>&1; then
            echo "No episodes found for ${series}; running planner to create one…"
            python planner/plan_next.py --series "${series}"
          fi

          # Find newest ep_*/ dir
          EP_DIR="$(ls -d "${root}"/ep_* 2>/dev/null | sort | tail -n1 || true)"
          if [ -z "$EP_DIR" ] || [ ! -d "$EP_DIR" ]; then
            echo "::error::No episode directory found under ${root} even after planning"
            exit 1
          fi
          echo "Newest episode: $EP_DIR"

          # Clean previous latest (dir/symlink/file)
          rm -rf "${root}/latest"

          # Try symlink first
          ln -s "$(basename "$EP_DIR")" "${root}/latest" || true

          # If latest is a symlink, we're done (plan.json accessible via link)
          if [ -L "${root}/latest" ]; then
            echo "latest/ is a symlink to: $(readlink -f "${root}/latest")"
          else
            # Fallback: make real dir and copy plan.json
            mkdir -p "${root}/latest"
            if [ -f "${EP_DIR}/plan.json" ]; then
              cp -f "${EP_DIR}/plan.json" "${root}/latest/plan.json"
            else
              echo "::error::Missing ${EP_DIR}/plan.json"
              exit 1
            fi
          fi

          echo "latest/ points to: ${root}/latest"
          ls -al "${root}" || true
          echo "Contents of latest/:"
          ls -al "${root}/latest" || true


      - name: Write narration (LLM)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          python planner/agent_director.py

      # --------- TTS BEFORE SRT ----------
      - name: Voiceover (TTS)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          # Use your existing TTS entrypoint; it may write different filenames/locations.
          python tts_openai.py --series "${SERIES}" || true

      - name: Ensure voice.wav (normalize or synthesize via OpenAI, bash-only)
        env:
          SERIES: ${{ matrix.series }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          series="${SERIES}"

          # Find latest episode dir for the series
          EP_DIR="$(ls -d "out/${series}"/ep_* 2>/dev/null | sort | tail -n1 || true)"
          if [ -z "$EP_DIR" ] || [ ! -d "$EP_DIR" ]; then
            echo "::error::No episode directory found under out/${series}"
            exit 1
          fi
          ASSETS="${EP_DIR}/assets"
          mkdir -p "$ASSETS"

          echo "== EP_DIR: ${EP_DIR} =="
          echo "== EP_DIR listing =="
          ls -al "${EP_DIR}" || true
          echo "== assets listing =="
          ls -al "${ASSETS}" || true

          # If already present, done.
          if [ -f "${ASSETS}/voice.wav" ]; then
            echo "voice.wav already present"
            exit 0
          fi

          # Try to normalize common TTS outputs → assets/voice.wav
          FOUND=""
          for f in \
            "${EP_DIR}/voice.wav" "${EP_DIR}/narration.wav" "${EP_DIR}/audio.wav" \
            "${ASSETS}/narration.wav" "${ASSETS}/audio.wav" \
            "${EP_DIR}/voice.mp3" "${ASSETS}/voice.mp3" \
            "${EP_DIR}/narration.mp3" "${ASSETS}/narration.mp3"
          do
            if [ -f "$f" ]; then FOUND="$f"; break; fi
          done

          if [ -n "$FOUND" ]; then
            if [[ "$FOUND" == *.mp3 ]]; then
              echo "Converting MP3 → WAV: $FOUND"
              ffmpeg -y -hide_banner -loglevel error -i "$FOUND" -ar 48000 -ac 1 "${ASSETS}/voice.wav"
            else
              echo "Copying WAV: $FOUND"
              cp -f "$FOUND" "${ASSETS}/voice.wav"
            fi
            echo "Ready: ${ASSETS}/voice.wav"
            ls -al "${ASSETS}"
            exit 0
          fi

          # Fallback synth via OpenAI TTS if nothing found.
          # Requires narration text and OPENAI_API_KEY.
          TXT="${ASSETS}/narration.txt"
          if [ ! -f "$TXT" ]; then
            echo "::error::No narration.txt to synthesize at ${TXT}"
            exit 1
          fi
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "::error::OPENAI_API_KEY missing for fallback TTS"
            exit 1
          fi

          echo "Synthesizing voice.wav via OpenAI TTS fallback…"
          # Build JSON body with jq (no heredoc Python)
          BODY="$(jq -n --arg model "tts-1" --arg voice "alloy" --arg input "$(< "$TXT")" --arg format "wav" \
            '{model:$model, voice:$voice, input:$input, format:$format}')"

          # POST /v1/audio/speech → binary WAV
          curl -sS -X POST "https://api.openai.com/v1/audio/speech" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -H "Content-Type: application/json" \
            --data "${BODY}" \
            --output "${ASSETS}/voice.wav"

          if [ ! -s "${ASSETS}/voice.wav" ]; then
            echo "::error::Fallback TTS did not produce audio"
            exit 1
          fi

          echo "== Final assets =="
          ls -al "${ASSETS}"

      - name: Make SRT from narration (align to voice.wav)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python generator/make_srt.py --series "${SERIES}"

      - name: Build shotlist (beats)
        env:
          SERIES: ${{ matrix.series }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          VIS_GEN_MODEL: ${{ env.VIS_GEN_MODEL }} # optional: if your script reads this
        run: |
          set -e
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "::error::OPENAI_API_KEY is missing (set it in repo Settings → Secrets and variables → Actions)"
            exit 1
          fi
          python generator/make_shotlist.py --series "${SERIES}"

      
      - name: Debug assets before routing
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          EP_DIR="$(ls -d out/${SERIES}/ep_* 2>/dev/null | sort | tail -n1 || true)"
          echo "EP_DIR=$EP_DIR"
          ls -al "$EP_DIR/assets" || true

      - name: Route shots (beats & timings)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python generator/route_shots.py --series "${SERIES}"

      # --------- WB3: LLM → CODE → RENDER ----------
      - name: Generate per-beat visuals code (LLM → Python)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python generator/gen_visuals_code.py --series "${SERIES}"
      
      - name: Sync latest → visuals_code.py
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          series="${SERIES:?SERIES env missing}"
          root="out/${series}"
          EP_DIR="$(ls -d "${root}"/ep_* 2>/dev/null | sort | tail -n1 || true)"
          if [ -z "$EP_DIR" ] || [ ! -d "$EP_DIR" ]; then
            echo "::error::No episode directory found under ${root}"
            exit 1
          fi
          SRC="${EP_DIR}/assets/visuals_code.py"
          if [ ! -f "$SRC" ]; then
            echo "::error::visuals_code.py not found at $SRC (did gen_visuals_code run?)"
            exit 1
          fi
          mkdir -p "${root}/latest"
          # If latest is a symlink to the episode, we don't need to copy.
          if [ -L "${root}/latest" ]; then
            echo "latest/ is a symlink; visuals_code.py already visible via ${root}/latest"
            ls -al "${root}/latest" || true
          else
            cp -f "$SRC" "${root}/latest/visuals_code.py"
            echo "Copied $SRC -> ${root}/latest/visuals_code.py"
          fi
          echo "== latest listing =="
          ls -al "${root}/latest" || true

      
      - name: Debug generated visuals code (head)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          EP_DIR="$(ls -d out/${SERIES}/ep_* 2>/dev/null | sort | tail -n1 || true)"
          CODE="${EP_DIR}/assets/visuals_code.py"
          echo "== Showing first 60 lines of visuals_code.py =="
          nl -ba "$CODE" | sed -n '1,60p' || true
          if [ -f "${EP_DIR}/assets/visuals_code_error.txt" ]; then
            echo "== visuals_code_error.txt =="
            cat "${EP_DIR}/assets/visuals_code_error.txt" || true
          fi

      - name: Render per-beat visuals
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python generator/render_visuals.py --series "${SERIES}"

      # --------- BACKGROUND & CUT ----------
      - name: Generate background (fallback/safety)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python generator/gen_background.py --series "${SERIES}"

      - name: Cut visuals (assemble beats)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python assembly/cut_visuals.py --series "${SERIES}"

      # --------- FINAL ASSEMBLY ----------
      - name: Build final MP4
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python assembly/build_video.py --series "${SERIES}"

      - name: Validate final MP4
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python assembly/validate_video.py --series "${SERIES}"

      # --------- RESOLVE OUTPUT & CAPTION (bash + jq only) ----------
      - name: Resolve final mp4 & caption
        id: meta
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          series="${SERIES}"

          PLAN="$(ls -t "out/${series}"/ep_*/plan.json 2>/dev/null | head -n1 || true)"
          MP4=""
          if [ -n "$PLAN" ] && [ -f "$PLAN" ]; then
            MP4="$(jq -r '.video_path // ""' "$PLAN")"
          fi
          if [ -z "$MP4" ] || [ ! -f "$MP4" ]; then
            MP4="$(ls -t "out/${series}"/final/*.mp4 2>/dev/null | head -n1 || true)"
          fi
          if [ -z "$MP4" ] || [ ! -f "$MP4" ]; then
            echo "No final mp4 found" >&2
            exit 1
          fi

          EP_DIR=""
          if [ -n "$PLAN" ]; then
            EP_DIR="$(dirname "$PLAN")"
          else
            EP_DIR="$(dirname "$(dirname "$MP4")")"
          fi

          TITLE="$(cat "$EP_DIR/assets/title.txt" 2>/dev/null || echo "${series} Daily")"
          OVERLAY="$(cat "$EP_DIR/assets/overlay.txt" 2>/dev/null || echo "New episode!")"
          CAPTION="${TITLE} — ${OVERLAY}"

          {
            echo "mp4=$MP4"
            echo "ep_dir=$EP_DIR"
            echo "caption<<EOF"
            echo "$CAPTION"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      # --------- PUBLISH TO GH-PAGES ----------
      - name: Push MP4 to gh-pages
        id: publish
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SERIES: ${{ matrix.series }}
          REPO: ${{ github.repository }}
        run: |
          set -e
          series="${SERIES}"
          FILE="${{ steps.meta.outputs.mp4 }}"
          NAME="${series}-${GITHUB_RUN_ID}.mp4"

          git config --global user.name  "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          if [ ! -d site ]; then
            git clone --depth=1 --branch gh-pages \
              "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git" site
          fi

          mkdir -p "site/reels/${series}"
          cp "$FILE" "site/reels/${series}/${NAME}"

          cd site
          git add "reels/${series}/${NAME}"
          git commit -m "reel: ${NAME} (${series}) from run ${GITHUB_RUN_ID}" || true

          for i in 1 2 3 4 5; do
            git pull --rebase origin gh-pages || true
            if git push origin HEAD:gh-pages; then
              break
            fi
            echo "Push failed (attempt $i). Retrying…"
            sleep 2
            if [ "$i" = "5" ]; then
              echo "Push failed after retries"
              exit 1
            fi
          done

          URL="https://${REPO%%/*}.github.io/${REPO#*/}/reels/${series}/${NAME}"
          {
            echo "name=$NAME"
            echo "url=$URL"
          } >> "$GITHUB_OUTPUT"

      # --------- POST TO INSTAGRAM ----------
      - name: Post to Instagram (math_of_ML real; others dry)
        if: always()
        env:
          SERIES: ${{ matrix.series }}
          IG_ACCESS_TOKEN: ${{ secrets.IG_ACCESS_TOKEN }}
          IG_USER_ID: ${{ secrets.IG_USER_ID }}
        run: |
          set -e
          series="${SERIES}"
          URL="${{ steps.publish.outputs.url }}"
          CAPTION="${{ steps.meta.outputs.caption }}"

          echo "Series: $series"
          echo "URL: $URL"

          if [ "$series" = "math_of_ML" ]; then
            if [ -z "$IG_ACCESS_TOKEN" ] || [ -z "$IG_USER_ID" ]; then
              echo "Instagram secrets missing; skipping real post."
              exit 0
            fi
            echo "Posting (REAL) for ${series}: $URL"
            python publisher/post_instagram.py "$URL" "$CAPTION"
          else
            echo "[dry-run] Would post for ${series}: $URL"
