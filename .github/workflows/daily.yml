name: daily-episodes

on:
  schedule:
    - cron: "0 15 * * *"     # daily at 15:00 UTC (10:00 America/Chicago)
  workflow_dispatch:

permissions:
  contents: write

jobs:
  episode:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # Three channels: math_of_ML (real post), MAS (dry), mixed (dry)
        series: [math_of_ML, MAS, mixed]

    concurrency:
      group: daily-${{ matrix.series }}
      cancel-in-progress: false
    timeout-minutes: 45

    env:
      PYTHONUNBUFFERED: "1"
      PYTHONPATH: ${{ github.workspace }}   # so adapters import cleanly
      BG_COLOR: "0x101426"

    steps:
      - uses: actions/checkout@v4

      # --- System deps for visuals ---
      - name: Install system deps
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg graphviz fonts-dejavu-core

      # --- Python setup ---
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('infra/requirements.txt') }}
          restore-keys: ${{ runner.os }}-pip-

      # --- Vendor wheels (Option A) OR fallback to pip ---
      - name: Install Python deps (prefer vendor wheels)
        run: |
          set -e
          if ls vendor/wheels/*.whl 1>/dev/null 2>&1; then
            echo "[deps] Installing vendor wheels…"
            pip install vendor/wheels/*.whl
          fi
          # Ensure core deps present even without vendor wheels
          pip install --upgrade pip
          pip install numpy pillow
          pip install matplotlib networkx graphviz pyyaml pandas requests openai

      # ----------------- PIPELINE -----------------

      - name: Plan episode (cursor + curriculum)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          python planner/plan_next.py --series "${SERIES}"

      - name: Director agent (strict summary)
        env:
          SERIES: ${{ matrix.series }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: gpt-4o
        run: |
          python planner/agent_director.py --series "${SERIES}"

      - name: Generate assets (TTS, texts)
        env:
          SERIES: ${{ matrix.series }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_TTS_MODEL: gpt-4o-mini-tts
          OPENAI_TTS_VOICE: verse
        run: |
          python generator/gen_assets.py --series "${SERIES}"
      
      - name: Debug narration & voice
        run: |
          EP=$(ls -td out/${{ matrix.series }}/ep_* | head -n1)
          echo "EPISODE: $EP"
          echo "--- narration.txt ---"
          wc -w "$EP/assets/narration.txt" || true
          echo "--- voice.wav duration ---"
          ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$EP/assets/voice.wav" || true


      - name: Generate background (calm color)
        env:
          SERIES: ${{ matrix.series }}
          BG_COLOR: ${{ env.BG_COLOR }}
        run: |
          python generator/gen_background.py --series "${SERIES}"
        
      - name: Cap background to 90s
        run: |
          EP=$(ls -td out/${{ matrix.series }}/ep_* | head -n1)
          if [ -f "$EP/assets/bg.mp4" ]; then
            ffmpeg -y -i "$EP/assets/bg.mp4" -t 90 -c copy "$EP/assets/bg.mp4"
          fi


      - name: Make shotlist (adaptive beats)
        env:
          SERIES: ${{ matrix.series }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: gpt-4o
        run: |
          python planner/make_shotlist.py --series "${SERIES}"

      - name: Route beats → topic adapters (no stock)
        env:
          SERIES: ${{ matrix.series }}
          PYTHONPATH: ${{ env.PYTHONPATH }}
        run: |
          python generator/route_shots.py --series "${SERIES}"

      - name: Cut visuals to narration length
        env:
          SERIES: ${{ matrix.series }}
        run: |
          python assembly/cut_visuals.py --series "${SERIES}"

      - name: Make subtitles (SRT)
        env:
          SERIES: ${{ matrix.series }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          python generator/make_srt.py --series "${SERIES}"

      - name: Assemble final video (titles/overlay/subs)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          python assembly/build_video.py --series "${SERIES}"

      - name: Validate final video
        env:
          SERIES: ${{ matrix.series }}
        run: |
          python assembly/validate_video.py --series "${SERIES}"

      # ---------- Resolve MP4 & caption ----------
      - name: Resolve final mp4 & caption (bash + jq)
        id: meta
        run: |
          set -euo pipefail
          sudo apt-get update -y >/dev/null
          sudo apt-get install -y jq >/dev/null

          series="${{ matrix.series }}"

          # Find latest plan.json (if any)
          PLAN="$(ls -t out/"$series"/ep_*/plan.json 2>/dev/null | head -n1 || true)"
          MP4=""

          # Prefer video_path recorded in plan.json
          if [ -n "$PLAN" ]; then
            MP4="$(jq -r '.video_path // ""' "$PLAN")"
          fi

          # Fallback: newest mp4 under out/<series>/final/
          if [ -z "$MP4" ] || [ ! -f "$MP4" ]; then
            MP4="$(ls -t out/"$series"/final/*.mp4 2>/dev/null | head -n1 || true)"
            #                    ^^^^^^^  <-- no inner quotes around the glob
          fi

          if [ -z "$MP4" ]; then
            echo "No final mp4 found" >&2
            exit 1
          fi

          FILE_BASENAME="$(basename "$MP4")"

          # Determine the episode dir for captions (works even if PLAN is empty)
          if [ -n "$PLAN" ]; then
            EP_DIR="$(dirname "$PLAN")"
          else
            EP_DIR="$(dirname "$(dirname "$MP4")")"
          fi

          TITLE="$(cat "$EP_DIR/assets/title.txt" 2>/dev/null || echo "${series} Daily")"
          OVERLAY="$(cat "$EP_DIR/assets/overlay.txt" 2>/dev/null || echo "New episode!")"
          CAPTION="${TITLE} — ${OVERLAY}"

          {
            echo "mp4=$MP4"
            echo "file=$FILE_BASENAME"
            echo "caption<<EOF"
            echo "$CAPTION"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Cap final to 90s
        run: |
          series="${{ matrix.series }}"
          FINAL=$(ls -t out/"$series"/final/*.mp4 2>/dev/null | head -n1 || true)
          if [ -n "$FINAL" ]; then
            ffmpeg -y -i "$FINAL" -t 90 -c copy "$FINAL"
          fi

      # ---------- Publish to gh-pages (robust push) ----------
      - name: Publish MP4 to gh-pages
        id: publish
        env:
          GH_REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}   # auto-provided token
        run: |
          set -euo pipefail

          series="${{ matrix.series }}"
          FILE="${{ steps.meta.outputs.mp4 }}"
          NAME="${series}-${{ github.run_id }}.mp4"

          git config --global user.name  "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Clone with token (so push is authenticated)
          if [ ! -d site ]; then
            git clone --depth=1 --branch gh-pages \
              "https://x-access-token:${GH_TOKEN}@github.com/${GH_REPO}.git" site
          fi

          mkdir -p "site/reels/$series"
          cp "$FILE" "site/reels/$series/$NAME"

          cd site
          git add "reels/$series/$NAME"
          git commit -m "reel: $NAME ($series) from run ${{ github.run_id }}" || true
          # Rebase + push with token-backed remote
          git pull --rebase origin gh-pages || true
          git push origin HEAD:gh-pages
          echo "name=$NAME" >> "$GITHUB_OUTPUT"

      - name: Compute public URL
        id: url
        run: |
          OWNER="${GITHUB_REPOSITORY_OWNER}"
          REPO="${GITHUB_REPOSITORY#*/}"
          FILE="${{ steps.publish.outputs.name }}"
          BASE="https://${OWNER}.github.io/${REPO}"
          URL="${BASE}/reels/${{ matrix.series }}/${FILE}"
          echo "url=${URL}" >> $GITHUB_OUTPUT
          echo "Public URL: ${URL}"

      - name: Wait for file to be live
        id: head
        run: |
          set -e
          URL="${{ steps.url.outputs.url }}"
          for i in {1..90}; do
            code=$(curl -sI -o /dev/null -w "%{http_code}" "$URL" || true)
            ctype=$(curl -sI "$URL" | awk -F': ' 'tolower($1)=="content-type"{print tolower($2)}' | tr -d '\r' || true)
            echo "[try $i] code=$code ctype=$ctype"
            if [ "$code" = "200" ] && [[ "$ctype" == video/* ]]; then
              echo "live=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 2
          done
          echo "live=false" >> $GITHUB_OUTPUT
          exit 0

      # ---------- Instagram rules ----------
      - name: Post to Instagram — REAL (math_of_ML only)
        if: ${{ matrix.series == 'math_of_ML' && steps.head.outputs.live == 'true' }}
        env:
          IG_ACCESS_TOKEN: ${{ secrets.IG_ACCESS_TOKEN }}
          IG_USER_ID: ${{ secrets.IG_USER_ID }}
        run: |
          URL="${{ steps.url.outputs.url }}"
          CAP="${{ steps.meta.outputs.caption }}"
          echo "Posting (REAL) for math_of_ML: $URL"
          python publisher/post_instagram.py "$URL" "$CAP"

      - name: Post to Instagram — DRY RUN (MAS, mixed)
        if: ${{ matrix.series != 'math_of_ML' && steps.head.outputs.live == 'true' }}
        run: |
          echo "[DRY] Would post URL: ${{ steps.url.outputs.url }}"
          echo "[DRY] CAPTION: ${{ steps.meta.outputs.caption }}"

      - name: Upload final mp4 artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.series }}-final
          path: out/${{ matrix.series }}/final/*.mp4
