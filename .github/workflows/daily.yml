name: Daily Curriculum Reels

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 14 * * *"   # ~08:00 America/Chicago (adjust if needed)

permissions:
  contents: write          # needed for pushing to gh-pages with GITHUB_TOKEN

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        series: [math_of_ML, MAS, mixed]

    env:
      PYTHONUNBUFFERED: 1
      PYTHONPATH: ${{ github.workspace }}
      BG_COLOR: "0x101426"                 # quote to preserve hex string
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

    steps:
      # -------------------------
      # 0) Repo + Python + system deps
      # -------------------------
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install system packages (ffmpeg, graphviz, jq, Cairo/Pango + dev headers)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y \
            ffmpeg graphviz jq \
            libcairo2 libpango-1.0-0 libpangocairo-1.0-0 \
            libcairo2-dev libpango1.0-dev pkg-config python3-dev \
            python3-cairo

      - name: Install Python deps (prefer vendored wheels, then build manimpango)
        run: |
          set -e
          python -m pip install --upgrade pip

          # 1) Prefer vendored wheels you committed in vendor/wheels (downloaded with --no-deps)
          if ls vendor/wheels/*.whl 1> /dev/null 2>&1; then
            echo "Installing vendored wheels from vendor/wheels/…"
            pip install --no-index --find-links vendor/wheels vendor/wheels/*.whl
          else
            echo "WARN: No vendored wheels found; falling back to PyPI."
          fi

          # 2) Build & install manimpango from source (no wheel for Linux cp311)
          #    This requires the dev headers installed above.
          pip install "manimpango==0.6.0"

          # 3) Install manim (lets pip pull its remaining light deps)
          pip install "manim==0.19.0"

          # 4) Light extras you use elsewhere
          pip install --upgrade pyyaml requests soundfile

      # Ensure minimal runtime state exists (helps first run)
      - name: Initialize season file if missing
        run: |
          mkdir -p data
          test -f data/season.json || echo '{"next_episode":1}' > data/season.json
          echo "season.json:" && cat data/season.json || true

      # -------------------------
      # 1) Plan next episode for this series
      # -------------------------
      - name: Plan next
        env:
          SERIES: ${{ matrix.series }}
        run: |
          python planner/plan_next.py --series "${SERIES}"

      # Helpful visibility: what did we just create?
      - name: Inspect out tree
        run: |
          echo "SERIES=${{ matrix.series }}"
          find out -maxdepth 3 -type f -name 'plan.json' -print || true
          find out -maxdepth 3 -type f -name 'narration.txt' -print || true

      # Detect whether an episode directory exists for this series
      - name: Detect episode for this series
        id: ep
        run: |
          series="${{ matrix.series }}"
          EP=$(ls -td out/"$series"/ep_* 2>/dev/null | head -n1 || true)
          if [ -z "$EP" ]; then
            echo "found=false" >> $GITHUB_OUTPUT
            echo "No episode folder for $series — downstream steps will be skipped."
          else
            echo "found=true" >> $GITHUB_OUTPUT
            echo "ep=$EP" >> $GITHUB_OUTPUT
            echo "Episode: $EP"
          fi

      # -------------------------
      # 2) Director (strict to textbook excerpt) → narration.txt
      # -------------------------
      - name: Write narration (director, strict)
        if: steps.ep.outputs.found == 'true'
        run: |
          python planner/agent_director.py

      # -------------------------
      # 3) Shotlist (12–18 beats)
      # -------------------------
      - name: Make shotlist
        if: steps.ep.outputs.found == 'true'
        run: |
          python planner/make_shotlist.py

      # -------------------------
      # 4) TTS (voice.wav) — robust finder + placeholder fallback
      # -------------------------
      - name: Synthesize voice (TTS)
        if: steps.ep.outputs.found == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          series="${{ matrix.series }}"
          EP="${{ steps.ep.outputs.ep }}"
          echo "Episode dir: $EP"

          CANDIDATES=("tts_openai.py" "generator/tts_openai.py" "audio/tts_openai.py" "tools/tts_openai.py")
          FOUND=""
          for C in "${CANDIDATES[@]}"; do
            if [ -f "$C" ]; then
              echo "Using TTS script: $C"
              python "$C" --series "$series"
              FOUND="yes"
              break
            fi
          done

          # Fallback: if no TTS script present, create short silent voice.wav so pipeline continues
          if [ -z "$FOUND" ]; then
            echo "WARN: No tts_openai.py found; creating placeholder voice.wav (2s)."
            mkdir -p "$EP/assets"
            ffmpeg -y -f lavfi -i anullsrc=r=48000:cl=mono -t 2.0 -c:a pcm_s16le "$EP/assets/voice.wav"
          fi

      # -------------------------
      # 5) Background (hardened; then clamp to 90s)
      # -------------------------
      - name: Generate background
        if: steps.ep.outputs.found == 'true'
        run: |
          python generator/gen_background.py --series "${{ matrix.series }}"

      - name: Cap background to 90s (safety)
        if: steps.ep.outputs.found == 'true'
        run: |
          EP="${{ steps.ep.outputs.ep }}"
          if [ -f "$EP/assets/bg.mp4" ]; then
            ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 "$EP/assets/bg.mp4" || true
            ffmpeg -y -i "$EP/assets/bg.mp4" -t 90 -c copy "$EP/assets/bg.mp4"
            echo "[cap] bg.mp4 clamped to 90s"
          fi

      # -------------------------
      # 6) Route beats to shots, then cut visuals; clamp
      # -------------------------
      - name: Route beats to shots
        if: steps.ep.outputs.found == 'true'
        run: |
          python generator/route_shots.py --series "${{ matrix.series }}"

      - name: Cut visuals to narration
        if: steps.ep.outputs.found == 'true'
        run: |
          python assembly/cut_visuals.py --series "${{ matrix.series }}"

      - name: Cap visuals to 90s (safety)
        if: steps.ep.outputs.found == 'true'
        run: |
          EP="${{ steps.ep.outputs.ep }}"
          if [ -f "$EP/assets/visuals.mp4" ]; then
            ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 "$EP/assets/visuals.mp4" || true
            ffmpeg -y -i "$EP/assets/visuals.mp4" -t 90 -c copy "$EP/assets/visuals.mp4"
            echo "[cap] visuals.mp4 clamped to 90s"
          fi

      # -------------------------
      # 7) Build the final (combines bg + visuals + audio/subs)
      # -------------------------
      - name: Build final video
        if: steps.ep.outputs.found == 'true'
        run: |
          python assembly/build_video.py --series "${{ matrix.series }}"

      - name: Cap final MP4 to 90s (safety)
        if: steps.ep.outputs.found == 'true'
        run: |
          series="${{ matrix.series }}"
          FINAL=$(ls -t out/"$series"/final/*.mp4 2>/dev/null | head -n1 || true)
          if [ -n "$FINAL" ]; then
            ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 "$FINAL" || true
            ffmpeg -y -i "$FINAL" -t 90 -c copy "$FINAL"
            echo "[cap] final clamped to 90s"
          fi

      # -------------------------
      # 8) Resolve final mp4 & caption (jq)
      # -------------------------
      - name: Resolve final mp4 & caption
        if: steps.ep.outputs.found == 'true'
        id: meta
        run: |
          set -euo pipefail
          series="${{ matrix.series }}"

          PLAN="$(ls -t out/${series}/ep_*/plan.json 2>/dev/null | head -n1 || true)"
          MP4=""
          if [ -n "$PLAN" ]; then
            MP4="$(jq -r '.video_path // ""' "$PLAN")"
          fi
          if [ -z "$MP4" ] || [ ! -f "$MP4" ]; then
            MP4="$(ls -t out/${series}/final/*.mp4 2>/dev/null | head -n1 || true)"
          fi
          if [ -z "$MP4" ]; then
            echo "No final mp4 found" >&2; exit 1
          fi
          FILE_BASENAME="$(basename "$MP4")"

          # Episode dir (for title/overlay)
          if [ -n "$PLAN" ]; then
            EP_DIR="$(dirname "$PLAN")"
          else
            EP_DIR="$(dirname "$(dirname "$MP4")")"
          fi
          TITLE="$(cat "$EP_DIR/assets/title.txt" 2>/dev/null || echo "${series} Daily")"
          OVERLAY="$(cat "$EP_DIR/assets/overlay.txt" 2>/dev/null || echo "New episode!")"
          CAPTION="${TITLE} — ${OVERLAY}"

          {
            echo "mp4=$MP4"
            echo "file=$FILE_BASENAME"
            echo "caption<<EOF"
            echo "$CAPTION"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      # -------------------------
      # 9) Publish to gh-pages (token-auth clone)
      # -------------------------
      - name: Publish MP4 to gh-pages
        if: steps.ep.outputs.found == 'true'
        id: publish
        env:
          GH_REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          series="${{ matrix.series }}"
          FILE="${{ steps.meta.outputs.mp4 }}"
          NAME="${series}-${{ github.run_id }}.mp4"

          git config --global user.name  "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          if [ ! -d site ]; then
            git clone --depth=1 --branch gh-pages \
              "https://x-access-token:${GH_TOKEN}@github.com/${GH_REPO}.git" site
          fi

          mkdir -p "site/reels/$series"
          cp "$FILE" "site/reels/$series/$NAME"

          cd site
          git add "reels/$series/$NAME"
          git commit -m "reel: $NAME ($series) from run ${{ github.run_id }}" || true
          git pull --rebase origin gh-pages || true
          git push origin HEAD:gh-pages

          echo "name=$NAME" >> "$GITHUB_OUTPUT"

      # -------------------------
      # 10) Post to Instagram (REAL for math_of_ML, DRY for others)
      # -------------------------
      - name: Post to Instagram (REAL for math_of_ML)
        if: steps.ep.outputs.found == 'true' && matrix.series == 'math_of_ML'
        env:
          IG_ACCESS_TOKEN: ${{ secrets.IG_ACCESS_TOKEN }}
          IG_USER_ID: ${{ secrets.IG_USER_ID }}
        run: |
          URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/reels/${{ matrix.series }}/${{ steps.publish.outputs.name }}"
          CAP="${{ steps.meta.outputs.caption }}"
          echo "Posting (REAL) for ${{ matrix.series }}: $URL"
          python publisher/post_instagram.py "$URL" "$CAP"

      - name: Post to Instagram (DRY for non-math_of_ML)
        if: steps.ep.outputs.found == 'true' && matrix.series != 'math_of_ML'
        run: |
          URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/reels/${{ matrix.series }}/${{ steps.publish.outputs.name }}"
          CAP="${{ steps.meta.outputs.caption }}"
          echo "DRY-RUN (no publish) for ${{ matrix.series }}:"
          echo "  URL: $URL"
          echo "  CAP: $CAP"
