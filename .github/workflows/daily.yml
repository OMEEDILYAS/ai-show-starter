# .github/workflows/daily.yml
name: Daily Reel

on:
  workflow_dispatch:
    inputs:
      series:
        description: "Choose a single series to run (math_of_ML | MAS | mixed). Leave empty to run all."
        required: false
        default: ""
  schedule:
    # Run once a day at 15:05 UTC (10:05a Chicago)
    - cron: "5 15 * * *"

concurrency:
  group: daily-reel-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  actions: read

env:
  PYTHONUNBUFFERED: 1
  PYTHONPATH: ${{ github.workspace }}
  BG_COLOR: 0x101426
  VIS_GEN_MODEL: gpt-4o-mini

jobs:
  build:
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        series: ${{ fromJSON( (github.event.inputs.series != '' && format('["{0}"]', github.event.inputs.series)) || '["math_of_ML","MAS","mixed"]' ) }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install system deps (ffmpeg, fonts, jq)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y ffmpeg fonts-dejavu-core jq

      - name: Install Python deps (prefer vendor wheels)
        run: |
          set -e
          python -m pip install --upgrade pip wheel
          if [ -d vendor/wheels ]; then
            echo "Installing from vendor/wheels…"
            python -m pip install --no-index --find-links vendor/wheels \
              numpy pillow matplotlib networkx graphviz \
              plotly kaleido vpython moderngl moderngl-window \
              pyyaml requests orjson openai pandas
          else
            echo "vendor/wheels not found; installing from PyPI…"
            python -m pip install \
              numpy pillow matplotlib networkx graphviz \
              plotly kaleido vpython moderngl moderngl-window \
              pyyaml requests orjson openai pandas
          fi

      - name: Prepare folders
        run: |
          set -e
          mkdir -p "out/${{ matrix.series }}"

      # ---------- PLAN & NARRATION ----------
      - name: Plan next episode
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python planner/plan_next.py --series "${SERIES}"

      - name: Write narration (LLM)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          python planner/agent_director.py

      # ---------- TTS MUST RUN BEFORE SRT ----------
      - name: Voiceover (TTS)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          # Adjust path if your TTS entrypoint differs
          python generator/tts_openai.py --series "${SERIES}"

      - name: Normalize voice path for SRT
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          series="${SERIES}"

          # Find latest episode dir for the series
          EP_DIR="$(ls -d "out/${series}"/ep_* 2>/dev/null | sort | tail -n1 || true)"
          if [ -z "$EP_DIR" ] || [ ! -d "$EP_DIR" ]; then
            echo "::error::No episode directory found under out/${series}"
            exit 1
          fi

          mkdir -p "${EP_DIR}/assets"

          # Inspect what the TTS step actually produced
          echo "== After TTS, audio files in episode =="
          ls -al "${EP_DIR}" || true
          echo "== assets folder =="
          ls -al "${EP_DIR}/assets" || true

          # If voice.wav already exists in assets, we’re done
          if [ -f "${EP_DIR}/assets/voice.wav" ]; then
            echo "voice.wav already present at ${EP_DIR}/assets/voice.wav"
            exit 0
          fi

          # Common TTS outputs we’ll normalize to assets/voice.wav
          CANDIDATES=()
          CANDIDATES+=("${EP_DIR}/voice.wav")
          CANDIDATES+=("${EP_DIR}/narration.wav")
          CANDIDATES+=("${EP_DIR}/audio.wav")
          CANDIDATES+=("${EP_DIR}/assets/narration.wav")
          CANDIDATES+=("${EP_DIR}/assets/audio.wav")
          CANDIDATES+=("${EP_DIR}/voice.mp3")
          CANDIDATES+=("${EP_DIR}/assets/voice.mp3")
          CANDIDATES+=("${EP_DIR}/narration.mp3")
          CANDIDATES+=("${EP_DIR}/assets/narration.mp3")

          FOUND=""
          for f in "${CANDIDATES[@]}"; do
            if [ -f "$f" ]; then
              FOUND="$f"
              break
            fi
          done

          if [ -z "$FOUND" ]; then
            echo "::error::Could not find any voice audio (voice.wav/mp3, narration.wav/mp3, audio.wav) in ${EP_DIR} or assets/"
            exit 1
          fi

          # Convert to WAV if needed, then place exactly at assets/voice.wav
          if [[ "$FOUND" == *.mp3 ]]; then
            echo "Converting MP3 to WAV: $FOUND -> ${EP_DIR}/assets/voice.wav"
            ffmpeg -y -hide_banner -loglevel error -i "$FOUND" -ar 48000 -ac 1 "${EP_DIR}/assets/voice.wav"
          else
            echo "Moving WAV to assets/voice.wav: $FOUND"
            cp -f "$FOUND" "${EP_DIR}/assets/voice.wav"
          fi

          echo "== Final assets =="
          ls -al "${EP_DIR}/assets"


      - name: Make SRT from narration (align to voice.wav)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python generator/make_srt.py --series "${SERIES}"

      - name: Route shots (beats & timings)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python generator/route_shots.py --series "${SERIES}"

      # ---------- WB3: LLM → CODE → RENDER ----------
      - name: Generate per-beat visuals code (LLM → Python)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python generator/gen_visuals_code.py --series "${SERIES}"

      - name: Render per-beat visuals
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python generator/render_visuals.py --series "${SERIES}"

      # ---------- BACKGROUND & CUT ----------
      - name: Generate background (fallback/safety)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python generator/gen_background.py --series "${SERIES}"

      - name: Cut visuals (assemble beats)
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python assembly/cut_visuals.py --series "${SERIES}"

      # ---------- FINAL ASSEMBLY ----------
      - name: Build final MP4
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python assembly/build_video.py --series "${SERIES}"

      - name: Validate final MP4
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          python assembly/validate_video.py --series "${SERIES}"

      # ---------- RESOLVE OUTPUT & CAPTION (bash + jq; no inline Python) ----------
      - name: Resolve final mp4 & caption
        id: meta
        env:
          SERIES: ${{ matrix.series }}
        run: |
          set -e
          series="${SERIES}"

          # Latest plan.json
          PLAN="$(ls -t "out/${series}"/ep_*/plan.json 2>/dev/null | head -n1 || true)"
          MP4=""
          if [ -n "$PLAN" ] && [ -f "$PLAN" ]; then
            MP4="$(jq -r '.video_path // ""' "$PLAN")"
          fi
          # Fallback: latest mp4 in final/
          if [ -z "$MP4" ] || [ ! -f "$MP4" ]; then
            MP4="$(ls -t "out/${series}"/final/*.mp4 2>/dev/null | head -n1 || true)"
          fi
          if [ -z "$MP4" ] || [ ! -f "$MP4" ]; then
            echo "No final mp4 found" >&2
            exit 1
          fi

          FILE_BASENAME="$(basename "$MP4")"
          EP_DIR=""
          if [ -n "$PLAN" ]; then
            EP_DIR="$(dirname "$PLAN")"
          else
            EP_DIR="$(dirname "$(dirname "$MP4")")"
          fi

          TITLE="$(cat "$EP_DIR/assets/title.txt" 2>/dev/null || echo "${series} Daily")"
          OVERLAY="$(cat "$EP_DIR/assets/overlay.txt" 2>/dev/null || echo "New episode!")"
          CAPTION="${TITLE} — ${OVERLAY}"

          {
            echo "mp4=$MP4"
            echo "file=$FILE_BASENAME"
            echo "ep_dir=$EP_DIR"
            echo "caption<<EOF"
            echo "$CAPTION"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      # ---------- PUBLISH TO GH-PAGES ----------
      - name: Push MP4 to gh-pages
        id: publish
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SERIES: ${{ matrix.series }}
          REPO: ${{ github.repository }}
        run: |
          set -e
          series="${SERIES}"
          FILE="${{ steps.meta.outputs.mp4 }}"
          NAME="${series}-${GITHUB_RUN_ID}.mp4"

          git config --global user.name  "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          if [ ! -d site ]; then
            git clone --depth=1 --branch gh-pages \
              "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git" site
          fi

          mkdir -p "site/reels/${series}"
          cp "$FILE" "site/reels/${series}/${NAME}"

          cd site
          git add "reels/${series}/${NAME}"
          git commit -m "reel: ${NAME} (${series}) from run ${GITHUB_RUN_ID}" || true

          for i in 1 2 3 4 5; do
            git pull --rebase origin gh-pages || true
            if git push origin HEAD:gh-pages; then
              break
            fi
            echo "Push failed (attempt $i). Retrying…"
            sleep 2
            if [ "$i" = "5" ]; then
              echo "Push failed after retries"
              exit 1
            fi
          done

          URL="https://${REPO%%/*}.github.io/${REPO#*/}/reels/${series}/${NAME}"
          {
            echo "name=$NAME"
            echo "url=$URL"
          } >> "$GITHUB_OUTPUT"

      # ---------- POST TO INSTAGRAM ----------
      - name: Post to Instagram (math_of_ML real; others dry)
        if: always()
        env:
          SERIES: ${{ matrix.series }}
          IG_ACCESS_TOKEN: ${{ secrets.IG_ACCESS_TOKEN }}
          IG_USER_ID: ${{ secrets.IG_USER_ID }}
        run: |
          set -e
          series="${SERIES}"
          URL="${{ steps.publish.outputs.url }}"
          CAPTION="${{ steps.meta.outputs.caption }}"

          echo "Series: $series"
          echo "URL: $URL"

          if [ "$series" = "math_of_ML" ]; then
            if [ -z "$IG_ACCESS_TOKEN" ] || [ -z "$IG_USER_ID" ]; then
              echo "Instagram secrets missing; skipping real post."
              exit 0
            fi
            echo "Posting (REAL) for ${series}: $URL"
            python publisher/post_instagram.py "$URL" "$CAPTION"
          else
            echo "[dry-run] Would post for ${series}: $URL"
